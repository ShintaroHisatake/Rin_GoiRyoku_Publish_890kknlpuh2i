<!doctype html>
<html lang="ja">
<head>
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>語句学習アプリ</title>

  <!-- ライブラリ読み込み -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <meta name="color-scheme" content="light only"/>
</head>
<body class="bg-slate-50">
  <div id="root" class="min-h-screen"></div>

  <!-- JS エラーが出たら画面に表示する -->
  <script>
    window.onerror = function (message, source, lineno, colno, error) {
      var root = document.getElementById("root");
      if (!root) return;
      root.innerHTML =
        '<div style="padding:16px;font-family:monospace;color:#b91c1c;white-space:pre-wrap;">'
        + 'JavaScript エラーが発生しました:\\n'
        + message + '\\n'
        + (error && error.stack ? error.stack : '')
        + '</div>';
    };
  </script>

  <script type="text/babel" data-presets="env,react">
    const { useEffect, useState } = React;

    const Modes = { VIEW: "VIEW", MCQ: "MCQ" };
    const Groups = { DAY: "DAY", WEEK: "WEEK" };

    const fetchJson = async (path) => {
      const res = await fetch(path, { cache: "no-store" });
      if (!res.ok) {
        throw new Error(path + " を取得できません（" + res.status + "）");
      }
      return await res.json();
    };

    const shuffle = (arr) => {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
      }
      return a;
    };

    // ========= ルートコンポーネント =========
    function App() {
      const [data, setData] = useState(null);
      const [error, setError] = useState("");
      const [loading, setLoading] = useState(true);

      const [group, setGroup] = useState(Groups.DAY);
      const [dayId, setDayId] = useState("DAY1");
      const [mode, setMode] = useState(Modes.VIEW);

      useEffect(() => {
        (async () => {
          try {
            const j = await fetchJson("./data/week1.json");
            if (!j || !j.days || !Array.isArray(j.days)) {
              throw new Error("week1.json の形式が想定と違います（days 配列がありません）");
            }
            setData(j);
          } catch (e) {
            console.error("読み込みエラー", e);
            setError(e.message || String(e));
          } finally {
            setLoading(false);
          }
        })();
      }, []);

      if (loading) {
        return <div className="p-6 text-slate-600">データ読み込み中…</div>;
      }

      if (error) {
        return (
          <div className="max-w-3xl mx-auto p-6">
            <h1 className="text-2xl font-bold mb-3">読み込みエラー</h1>
            <p className="text-red-600 whitespace-pre-wrap">{error}</p>
            <p className="mt-3 text-sm text-slate-600">
              ・リポジトリ直下に <code>data/week1.json</code> があるか<br/>
              ・JSON に余計なカンマや全角記号が紛れていないか
            </p>
          </div>
        );
      }

      const days = data.days || [];
      const dayOptions = days.map((d) => ({ value: d.id, label: d.label }));

      // WEEK のときは days 全部を連結（week.items が空でも動くように）
      let activeItems = [];
      if (group === Groups.WEEK) {
        if (data.week && Array.isArray(data.week.items) && data.week.items.length > 0) {
          activeItems = data.week.items;
        } else {
          days.forEach((d) => {
            if (Array.isArray(d.items)) {
              activeItems = activeItems.concat(d.items);
            }
          });
        }
      } else {
        const day = days.find((d) => d.id === dayId);
        activeItems = day && Array.isArray(day.items) ? day.items : [];
      }

      return (
        <div className="max-w-5xl mx-auto p-6 grid gap-6">
          <header className="flex flex-wrap items-center justify-between gap-3">
            <h1 className="text-2xl md:text-3xl font-bold">語句学習アプリ</h1>
            <div className="flex flex-wrap items-center gap-2">
              <select
                className="px-3 py-2 rounded-xl border bg-white"
                value={group}
                onChange={(e) => setGroup(e.target.value)}
              >
                <option value={Groups.DAY}>Dayごと</option>
                <option value={Groups.WEEK}>週ごと（全体）</option>
              </select>

              {group === Groups.DAY && (
                <select
                  className="px-3 py-2 rounded-xl border bg-white"
                  value={dayId}
                  onChange={(e) => setDayId(e.target.value)}
                >
                  {dayOptions.map((opt) => (
                    <option key={opt.value} value={opt.value}>{opt.label}</option>
                  ))}
                </select>
              )}

              <select
                className="px-3 py-2 rounded-xl border bg-white"
                value={mode}
                onChange={(e) => setMode(e.target.value)}
              >
                <option value={Modes.VIEW}>モード1：語句・意味・例文を表示</option>
                <option value={Modes.MCQ}>モード2：意味→語句（10択）</option>
              </select>
            </div>
          </header>

          <main className="rounded-2xl border bg-white p-6 shadow-sm">
            {mode === Modes.VIEW ? (
              <ModeView items={activeItems} />
            ) : (
              <ModeMCQ items={activeItems} />
            )}
          </main>

          <footer className="text-center text-xs text-slate-500">
            <p>© {new Date().getFullYear()} 語句学習</p>
          </footer>
        </div>
      );
    }

    // ========= モード1：閲覧 =========
    function ModeView({ items }) {
      const [i, setI] = useState(0);
      const total = items.length;

      if (!total) {
        return <div className="text-slate-600">この範囲に項目がありません。</div>;
      }

      const cur = items[i];

      return (
        <div className="grid gap-6">
          <div className="flex items-center gap-2 text-sm">
            <span className="px-2 py-1 rounded-full bg-slate-100">
              項目 {i + 1} / {total}
            </span>
            <span className="ml-auto px-2 py-1 rounded-full bg-slate-900 text-white">
              全{total}件
            </span>
          </div>

          <div className="grid gap-4">
            <div>
              <div className="text-xs text-slate-500">語句</div>
              <div className="text-3xl md:text-4xl font-extrabold">{cur.term}</div>
            </div>
            <div>
              <div className="text-xs text-slate-500">意味</div>
              <div className="text-lg md:text-xl">{cur.meaning}</div>
            </div>
            {cur.example && (
              <div>
                <div className="text-xs text-slate-500">例文</div>
                <div className="text-base leading-relaxed">{cur.example}</div>
              </div>
            )}
          </div>

          <div className="flex items-center justify-between">
            <button
              className="px-4 py-2 rounded-xl border bg-white"
              onClick={() => setI((v) => (v - 1 < 0 ? total - 1 : v - 1))}
            >
              ← 前へ
            </button>
            <button
              className="px-4 py-2 rounded-xl bg-slate-900 text-white"
              onClick={() => setI((v) => (v + 1 >= total ? 0 : v + 1))}
            >
              次へ →
            </button>
          </div>
        </div>
      );
    }

    // ========= モード2：10択クイズ =========
    function ModeMCQ({ items }) {
      const [order, setOrder] = useState(() =>
        shuffle(items.map((_, i) => i))
      );
      const [qIdx, setQIdx] = useState(0);
      const [selected, setSelected] = useState(null);
      const [correct, setCorrect] = useState(null);
      const [score, setScore] = useState(0);

      useEffect(() => {
        setOrder(shuffle(items.map((_, i) => i)));
        setQIdx(0);
        setSelected(null);
        setCorrect(null);
        setScore(0);
      }, [items]);

      const total = items.length;
      if (!total) {
        return <div className="text-slate-600">この範囲に項目がありません。</div>;
      }

      const currentIndex = order[qIdx];
      const current = items[currentIndex];

      // useMemo をやめて、普通の関数で選択肢を計算（フック数を固定）
      const buildOptions = () => {
        const indices = items.map((_, i) => i);
        const others = indices.filter((i) => i !== currentIndex);
        const distractors = shuffle(others).slice(0, 9);
        return shuffle([currentIndex].concat(distractors));
      };
      const optionIndices = buildOptions();

      const submit = (idx) => {
        if (correct !== null) return;
        setSelected(idx);
        const ok = idx === currentIndex;
        setCorrect(ok);
        if (ok) setScore((s) => s + 1);
      };

      const nextQ = () => {
        setSelected(null);
        setCorrect(null);
        setQIdx((v) => (v + 1 >= order.length ? 0 : v + 1));
      };

      return (
        <div className="grid gap-6">
          <div className="flex items-center gap-2 text-sm">
            <span className="px-2 py-1 rounded-full bg-slate-100">
              問題 {qIdx + 1} / {order.length}
            </span>
            <span className="ml-auto px-2 py-1 rounded-full bg-slate-900 text-white">
              正答 {score} / {qIdx + (correct !== null ? 1 : 0)}
            </span>
          </div>

          <div>
            <div className="text-xs text-slate-500">意味</div>
            <div className="text-lg md:text-xl">{current.meaning}</div>
          </div>

          <ol className="grid md:grid-cols-2 gap-3">
            {optionIndices.map((idx, i) => {
              const term = items[idx].term;
              const isChosen = selected !== null && idx === selected;
              const isAnswer = selected !== null && idx === currentIndex;
              let cls = "w-full text-left px-4 py-3 rounded-xl border transition ";
              if (isAnswer) {
                cls += "bg-emerald-50 border-emerald-300";
              } else if (isChosen) {
                cls += "bg-rose-50 border-rose-300";
              } else {
                cls += "bg-white hover:bg-slate-50 border-slate-300";
              }
              return (
                <li key={i}>
                  <button
                    className={cls}
                    onClick={() => submit(idx)}
                    disabled={selected !== null}
                  >
                    <span className="mr-2 font-mono text-slate-500">
                      {String.fromCharCode(65 + i)}.
                    </span>
                    <span className="font-semibold">{term}</span>
                  </button>
                </li>
              );
            })}
          </ol>

          {selected !== null && (
            <div className="rounded-xl border p-4 bg-slate-50">
              <div className={"font-bold " + (correct ? "text-emerald-700" : "text-rose-700")}>
                {correct ? "正解！" : "不正解"}
              </div>
              {current.example && (
                <div className="mt-2 text-sm text-slate-700">
                  <span className="font-medium">例文：</span>
                  {current.example}
                </div>
              )}
              <div className="mt-3">
                <button
                  className="px-4 py-2 rounded-xl bg-slate-900 text-white"
                  onClick={nextQ}
                >
                  次の問題へ →
                </button>
              </div>
            </div>
          )}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);
  </script>

  <noscript>このアプリを使うにはJavaScriptを有効にしてください。</noscript>
</body>
</html>
