<!doctype html>
<html lang="ja">
<head>
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>語句学習アプリ</title>

  <!-- ライブラリ読み込み -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <meta name="color-scheme" content="light only"/>
</head>
<body class="bg-slate-50">
  <div id="root" class="min-h-screen"></div>

  <!-- JS エラーが出たら画面に表示する -->
  <script>
    window.onerror = function (message, source, lineno, colno, error) {
      var root = document.getElementById("root");
      if (!root) return;
      root.innerHTML =
        '<div style="padding:16px;font-family:monospace;color:#b91c1c;white-space:pre-wrap;">'
        + 'JavaScript エラーが発生しました:\n'
        + message + '\n'
        + (error && error.stack ? error.stack : '')
        + '</div>';
    };
  </script>

  <script type="text/babel" data-presets="env,react">
    const { useEffect, useState } = React;

    // ==== モード・グループ定義 ====
    const Modes = { VIEW: "VIEW", MCQ: "MCQ", FILL: "FILL" };
    const Groups = { DAY: "DAY", WEEK: "WEEK" };

    // 利用する JSON ファイルの一覧（必要に応じて追加）
    const DATASETS = [
      { id: "week1", label: "Week 1", path: "./data/week1.json" },
      { id: "week2", label: "Week 2", path: "./data/week2.json" } // まだ無ければ後で追加
    ];

    const fetchJson = async (path) => {
      const res = await fetch(path, { cache: "no-store" });
      if (!res.ok) {
        throw new Error(path + " を取得できません（" + res.status + "）");
      }
      return await res.json();
    };

    const shuffle = (arr) => {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
      }
      return a;
    };

    // 例文の中の語句を「（　　　）」に差し替える
    function makeBlankExample(example, term) {
      if (!example) return "";
      if (!term) return example;
      const idx = example.indexOf(term);
      if (idx === -1) {
        // 見つからない場合は最後に空欄を付ける
        return example.replace(/。?$/, "（　　　）$&");
      }
      return (
        example.slice(0, idx) +
        "（　　　）" +
        example.slice(idx + term.length)
      );
    }

    // ========= ルートコンポーネント =========
    function App() {
      const [datasetId, setDatasetId] = useState("week1");
      const [data, setData] = useState(null);
      const [error, setError] = useState("");
      const [loading, setLoading] = useState(true);

      const [group, setGroup] = useState(Groups.DAY);
      const [dayId, setDayId] = useState("DAY1");
      const [mode, setMode] = useState(Modes.VIEW);

      // データセット読み込み
      useEffect(() => {
        (async () => {
          setLoading(true);
          setError("");
          setData(null);
          try {
            const ds = DATASETS.find(d => d.id === datasetId);
            if (!ds) throw new Error("不明なデータセットです: " + datasetId);
            const j = await fetchJson(ds.path);
            if (!j || !j.days || !Array.isArray(j.days)) {
              throw new Error("JSON の形式が想定と違います（days 配列がありません）");
            }
            setData(j);
            // DAY はそのデータの先頭にリセット
            if (j.days && j.days.length > 0) {
              setDayId(j.days[0].id);
            }
          } catch (e) {
            console.error("読み込みエラー", e);
            setError(e.message || String(e));
          } finally {
            setLoading(false);
          }
        })();
      }, [datasetId]);

      const days = data && data.days ? data.days : [];
      const dayOptions = days.map((d) => ({ value: d.id, label: d.label }));

      // WEEK のときは days 全部を連結（week.items が空でも動くように）
      let activeItems = [];
      if (data) {
        if (group === Groups.WEEK) {
          if (data.week && Array.isArray(data.week.items) && data.week.items.length > 0) {
            activeItems = data.week.items;
          } else {
            days.forEach((d) => {
              if (Array.isArray(d.items)) {
                activeItems = activeItems.concat(d.items);
              }
            });
          }
        } else {
          const day = days.find((d) => d.id === dayId);
          activeItems = day && Array.isArray(day.items) ? day.items : [];
        }
      }

      const currentDatasetLabel =
        DATASETS.find(d => d.id === datasetId)?.label || datasetId;

      return (
        <div className="max-w-5xl mx-auto p-6 grid gap-6">
          <header className="flex flex-wrap items-center justify-between gap-3">
            <h1 className="text-2xl md:text-3xl font-bold">語句学習アプリ</h1>
            <div className="flex flex-wrap items-center gap-2">
              {/* データセット選択 */}
              <select
                className="px-3 py-2 rounded-xl border bg-white"
                value={datasetId}
                onChange={(e) => setDatasetId(e.target.value)}
                title="週データ選択"
              >
                {DATASETS.map(ds => (
                  <option key={ds.id} value={ds.id}>{ds.label}</option>
                ))}
              </select>

              {/* Day / Week */}
              <select
                className="px-3 py-2 rounded-xl border bg-white"
                value={group}
                onChange={(e) => setGroup(e.target.value)}
              >
                <option value={Groups.DAY}>Dayごと</option>
                <option value={Groups.WEEK}>週ごと（全体）</option>
              </select>

              {group === Groups.DAY && (
                <select
                  className="px-3 py-2 rounded-xl border bg-white"
                  value={dayId}
                  onChange={(e) => setDayId(e.target.value)}
                >
                  {dayOptions.map((opt) => (
                    <option key={opt.value} value={opt.value}>{opt.label}</option>
                  ))}
                </select>
              )}

              {/* モード選択 */}
              <select
                className="px-3 py-2 rounded-xl border bg-white"
                value={mode}
                onChange={(e) => setMode(e.target.value)}
              >
                <option value={Modes.VIEW}>モード1：語句・意味・例文を表示</option>
                <option value={Modes.MCQ}>モード2：意味→語句（10択）</option>
                <option value={Modes.FILL}>モード3：例文穴埋め</option>
              </select>
            </div>
          </header>

          <section className="text-xs text-slate-500">
            使用中データセット：{currentDatasetLabel}
          </section>

          <main className="rounded-2xl border bg-white p-6 shadow-sm min-h-[200px]">
            {loading && (
              <div className="text-slate-600">データ読み込み中…</div>
            )}

            {!loading && error && (
              <div className="text-red-700 whitespace-pre-wrap">
                読み込みエラー：{error}
                <div className="mt-2 text-xs text-slate-500">
                  ・<code>{currentDatasetLabel}</code> 用の JSON ファイルが存在するか確認してください。<br/>
                  ・パス：<code>{DATASETS.find(d=>d.id===datasetId)?.path}</code>
                </div>
              </div>
            )}

            {!loading && !error && data && (
              <>
                {mode === Modes.VIEW && <ModeView items={activeItems} />}
                {mode === Modes.MCQ && <ModeMCQ items={activeItems} />}
                {mode === Modes.FILL && <ModeFill items={activeItems} />}
              </>
            )}
          </main>

          <footer className="text-center text-xs text-slate-500">
            <p>© {new Date().getFullYear()} 語句学習</p>
          </footer>
        </div>
      );
    }

    // ========= モード1：閲覧（語句＋読み＋意味＋例文）=========
    function ModeView({ items }) {
      const [i, setI] = useState(0);
      const total = items.length;

      if (!total) {
        return <div className="text-slate-600">この範囲に項目がありません。</div>;
      }

      const cur = items[i];

      return (
        <div className="grid gap-6">
          <div className="flex items-center gap-2 text-sm">
            <span className="px-2 py-1 rounded-full bg-slate-100">
              項目 {i + 1} / {total}
            </span>
            <span className="ml-auto px-2 py-1 rounded-full bg-slate-900 text-white">
              全{total}件
            </span>
          </div>

          <div className="grid gap-4">
            <div>
              <div className="text-xs text-slate-500">語句</div>
              <div className="text-3xl md:text-4xl font-extrabold">{cur.term}</div>
            </div>

            {cur.reading && (
              <div>
                <div className="text-xs text-slate-500">読み</div>
                <div className="text-lg md:text-xl">{cur.reading}</div>
              </div>
            )}

            <div>
              <div className="text-xs text-slate-500">意味</div>
              <div className="text-lg md:text-xl">{cur.meaning}</div>
            </div>

            {cur.example && (
              <div>
                <div className="text-xs text-slate-500">例文</div>
                <div className="text-base leading-relaxed">{cur.example}</div>
              </div>
            )}
          </div>

          <div className="flex items-center justify-between">
            <button
              className="px-4 py-2 rounded-xl border bg-white"
              onClick={() => setI((v) => (v - 1 < 0 ? total - 1 : v - 1))}
            >
              ← 前へ
            </button>
            <button
              className="px-4 py-2 rounded-xl bg-slate-900 text-white"
              onClick={() => setI((v) => (v + 1 >= total ? 0 : v + 1))}
            >
              次へ →
            </button>
          </div>
        </div>
      );
    }

    // ========= モード2：10択クイズ =========
    function ModeMCQ({ items }) {
      const [order, setOrder] = useState(() =>
        shuffle(items.map((_, i) => i))
      );
      const [qIdx, setQIdx] = useState(0);
      const [selected, setSelected] = useState(null);
      const [correct, setCorrect] = useState(null);
      const [score, setScore] = useState(0);

      useEffect(() => {
        setOrder(shuffle(items.map((_, i) => i)));
        setQIdx(0);
        setSelected(null);
        setCorrect(null);
        setScore(0);
      }, [items]);

      const total = items.length;
      if (!total) {
        return <div className="text-slate-600">この範囲に項目がありません。</div>;
      }

      const currentIndex = order[qIdx];
      const current = items[currentIndex];

      const buildOptions = () => {
        const indices = items.map((_, i) => i);
        const others = indices.filter((i) => i !== currentIndex);
        const distractors = shuffle(others).slice(0, 9);
        return shuffle([currentIndex].concat(distractors));
      };
      const optionIndices = buildOptions();

      const goNext = () => {
        setSelected(null);
        setCorrect(null);
        setQIdx((v) => (v + 1 >= order.length ? 0 : v + 1));
      };

      const submit = (idx) => {
        if (correct !== null) return;
        setSelected(idx);
        const ok = idx === currentIndex;
        setCorrect(ok);
        if (ok) setScore((s) => s + 1);
      };

      // Enterキーで「次の問題へ」
      useEffect(() => {
        const handler = (e) => {
          if (e.key === "Enter" && selected !== null) {
            e.preventDefault();
            goNext();
          }
        };
        window.addEventListener("keydown", handler);
        return () => window.removeEventListener("keydown", handler);
      }, [selected, order.length]);

      const chosenItem = selected !== null ? items[selected] : null;

      return (
        <div className="grid gap-6">
          <div className="flex items-center gap-2 text-sm">
            <span className="px-2 py-1 rounded-full bg-slate-100">
              問題 {qIdx + 1} / {order.length}
            </span>
            <span className="ml-auto px-2 py-1 rounded-full bg-slate-900 text-white">
              正答 {score} / {qIdx + (correct !== null ? 1 : 0)}
            </span>
          </div>

          <div>
            <div className="text-xs text-slate-500">意味</div>
            <div className="text-lg md:text-xl">{current.meaning}</div>
          </div>

          <ol className="grid md:grid-cols-2 gap-3">
            {optionIndices.map((idx, i) => {
              const term = items[idx].term;
              const isChosen = selected !== null && idx === selected;
              const isAnswer = selected !== null && idx === currentIndex;
              let cls = "w-full text-left px-4 py-3 rounded-xl border transition ";
              if (isAnswer) {
                cls += "bg-emerald-50 border-emerald-300";
              } else if (isChosen) {
                cls += "bg-rose-50 border-rose-300";
              } else {
                cls += "bg-white hover:bg-slate-50 border-slate-300";
              }
              return (
                <li key={i}>
                  <button
                    className={cls}
                    onClick={() => submit(idx)}
                    disabled={selected !== null}
                  >
                    <span className="mr-2 font-mono text-slate-500">
                      {String.fromCharCode(65 + i)}.
                    </span>
                    <span className="font-semibold">{term}</span>
                  </button>
                </li>
              );
            })}
          </ol>

          {selected !== null && (
            <div className="rounded-xl border p-4 bg-slate-50">
              <div className={"font-bold " + (correct ? "text-emerald-700" : "text-rose-700")}>
                {correct ? "正解！" : "不正解"}
              </div>

              <div className="mt-2 text-sm text-slate-700 space-y-1">
                {/* 正解情報 */}
                <div>
                  正解：<span className="font-semibold">{current.term}</span>
                </div>
                <div>
                  正解の意味：{current.meaning}</div>

                {/* 間違えたときだけ、自分が選んだ語句の意味も表示 */}
                {!correct && chosenItem && (
                  <>
                    <div className="mt-2">
                      あなたが選んだ語句：<span className="font-semibold">{chosenItem.term}</span>
                    </div>
                    <div>その意味：{chosenItem.meaning}</div>
                  </>
                )}

                {current.example && (
                  <div className="mt-2">
                    例文：{current.example}
                  </div>
                )}
              </div>

              <div className="mt-3">
                <button
                  className="px-4 py-2 rounded-xl bg-slate-900 text-white"
                  onClick={goNext}
                >
                  次の問題へ →（Enterでも可）
                </button>
              </div>
            </div>
          )}
        </div>
      );
    }

    // ========= モード3：例文穴埋め =========
    function ModeFill({ items }) {
      const [order, setOrder] = useState(() =>
        shuffle(items.map((_, i) => i))
      );
      const [qIdx, setQIdx] = useState(0);
      const [input, setInput] = useState("");
      const [feedback, setFeedback] = useState(null); // {correct, item}
      const [score, setScore] = useState(0);
      const [tried, setTried] = useState(0);

      useEffect(() => {
        setOrder(shuffle(items.map((_, i) => i)));
        setQIdx(0);
        setInput("");
        setFeedback(null);
        setScore(0);
        setTried(0);
      }, [items]);

      const total = items.length;
      if (!total) {
        return <div className="text-slate-600">この範囲に項目がありません。</div>;
      }

      const currentIndex = order[qIdx];
      const current = items[currentIndex];

      const handleSubmit = () => {
        if (!current) return;
        const ans = (current.term || "").replace(/\s/g, "");
        const user = (input || "").replace(/\s/g, "");
        const ok = user === ans;
        setFeedback({ correct: ok, item: current });
        setTried((n) => n + 1);
        if (ok) setScore((s) => s + 1);
      };

      const nextQ = () => {
        setFeedback(null);
        setInput("");
        setQIdx((v) => (v + 1 >= order.length ? 0 : v + 1));
      };

      const blankExample = makeBlankExample(current.example || "", current.term);

      return (
        <div className="grid gap-6">
          <div className="flex items-center gap-2 text-sm">
            <span className="px-2 py-1 rounded-full bg-slate-100">
              問題 {qIdx + 1} / {order.length}
            </span>
            <span className="ml-auto px-2 py-1 rounded-full bg-slate-900 text-white">
              正答 {score} / {tried}
            </span>
          </div>

          {/* ★ 入るべき語句の意味を事前に表示 */}
          <div className="rounded-xl border border-slate-200 bg-slate-50 p-3 text-sm">
            <div className="text-xs text-slate-500 mb-1">ヒント（語句の意味）</div>
            <div>{current.meaning}</div>
          </div>

          <div>
            <div className="text-xs text-slate-500">例文（空欄に入る語句を入力）</div>
            <div className="text-base md:text-lg leading-relaxed mt-1">
              {blankExample}
            </div>
          </div>

          <div className="grid gap-2">
            <label className="text-sm text-slate-600">
              語句を入力（Enter 1回目で判定、2回目で次の問題）
            </label>
            <input
              type="text"
              className="px-4 py-3 rounded-xl border border-slate-300 focus:outline-none
                         focus:ring-4 focus:ring-slate-100"
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === "Enter") {
                  e.preventDefault();
                  if (!feedback) {
                    // 1回目の Enter：判定
                    handleSubmit();
                  } else {
                    // 2回目の Enter：次の問題へ
                    nextQ();
                  }
                }
              }}
            />
          </div>

          {!feedback && (
            <div>
              <button
                className="px-4 py-2 rounded-xl bg-slate-900 text-white"
                onClick={handleSubmit}
              >
                判定（Enter 1回目）
              </button>
            </div>
          )}

          {feedback && (
            <div className="rounded-xl border p-4 bg-slate-50">
              <div className={"font-bold " + (feedback.correct ? "text-emerald-700" : "text-rose-700")}>
                {feedback.correct ? "正解！" : "不正解"}
              </div>
              <div className="mt-2 text-sm text-slate-700">
                <div>
                  正解：<span className="font-semibold">{feedback.item.term}</span>
                </div>
                <div className="mt-1">
                  意味：{feedback.item.meaning}
                </div>
                {feedback.item.example && (
                  <div className="mt-2">
                    例文：{feedback.item.example}
                  </div>
                )}
              </div>
              <div className="mt-3">
                <button
                  className="px-4 py-2 rounded-xl bg-slate-900 text-white"
                  onClick={nextQ}
                >
                  次の問題へ →（Enter 2回目でも可）
                </button>
              </div>
            </div>
          )}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);
  </script>

  <noscript>このアプリを使うにはJavaScriptを有効にしてください。</noscript>
</body>
</html>
